import asyncio
# A Conceptual Overview of asyncio

# Концептуальный обзор, часть 1: высокий уровень
# цикл событий, функции сопрограмм, объекты сопрограмм, задачи и await.

# Цикл событий == Event Loop
"""
Всё asyncio происходит относительно цикла событий. 
Он — звезда шоу. Он как дирижёр оркестра. Он за кулисами управляет ресурсами. 
Некоторые полномочия ему предоставлены явно, но значительная часть его возможностей 
для выполнения задач основана на уважении и сотрудничестве его рабочих пчёл.
В более технических терминах цикл событий содержит набор заданий для запуска. 
Некоторые задания добавляются вами напрямую, а некоторые косвенно asyncio. 
Цикл событий берет задание из своего резерва работы и вызывает его (или «дает ему управление»), 
аналогично вызову функции, а затем это задание запускается. 
После приостановки или завершения он возвращает управление циклу событий. 
Затем цикл событий выбирает другое задание из своего пула и вызывает его. 
Вы можете приблизительно представить себе набор заданий как очередь: задания добавляются и затем обрабатываются по одному за раз, 
как правило (но не всегда) по порядку. 
Этот процесс повторяется бесконечно, а цикл событий бесконечно продолжается. 
Если больше нет заданий, ожидающих выполнения, цикл событий достаточно умен, чтобы отдохнуть и избежать ненужной траты циклов ЦП, 
и вернется, когда появится больше работы.
Эффективное выполнение зависит от эффективного распределения задач и сотрудничества; 
жадная задача может перехватить управление и оставить другие задачи голодать, 
делая общий подход с циклом событий бесполезным.
"""


# This creates an event loop and indefinitely cycles through
# its collection of jobs.
# event_loop = asyncio.new_event_loop() # Создать и возвращает новый объект цикла событий.
# event_loop.run_forever() # Выполнять цикл событий до вызова stop().

"""
Асинхронные функции и сопрограммы
Это простая и скучная функция Python:
"""
def hello_printer():
    print(
        "Hi, I am a lowly, simple printer, though I have all I "
        "need in life -- \nfresh paper and my dearly beloved octopus "
        "partner in crime."
    )

"""
Вызов обычной функции вызывает ее логику или тело:
"""
hello_printer()

# Hi, I am a lowly, simple printer, though I have all I need in life --
# fresh paper and my dearly beloved octopus partner in crime.
"""
# Функция async def , в отличие от простого def def, 
# делает эту функцию асинхронной (или «функцией сопрограммы»). 
# Вызов этой функции создаёт и возвращает объект сопрограммы .
"""
async def loudmouth_penguin(magic_number: int):
    print(
     "I am a super special talking penguin. Far cooler than that printer. "
     f"By the way, my lucky number is: {magic_number}."
    )
"""
Вызов асинхронной функции loudmouth_penguin не приводит к выполнению оператора печати; 
вместо этого создается объект сопрограммы:
"""
# loudmouth_penguin(magic_number=3)
# <coroutine object loudmouth_penguin at 0x104ed2740>

"""
Термины «функция сопрограммы» и «объект сопрограммы» часто путают, подразумевая под этим сопрограмму. 
Это может сбивать с толку! В этой статье под сопрограммой понимается объект сопрограммы, или, точнее, 
экземпляр types.CoroutineType(нативной сопрограммы). 
Обратите внимание, что сопрограммы также могут существовать как экземпляры collections.abc.Coroutine — это различие важно для проверки типов.
Сопрограмма представляет собой тело или логику функции. 
Сопрограмма должна быть явно запущена; опять же, простое создание сопрограммы не запускает её. 
Примечательно, что сопрограмму можно приостанавливать и возобновлять в различных точках тела функции. 
Именно эта возможность приостановки и возобновления обеспечивает асинхронное поведение!
Корутины и функции корутинов были созданы с использованием функциональности генераторов и функций-генераторов . 
Напомним, функция-генератор — это функция, которая yield выполняет s, например:
"""
def get_random_number():
    # This would be a bad random number generator!
    print("Hi")
    yield 1
    print("Hello")
    yield 7
    print("Howdy")
    yield 4
    ...
"""
Подобно функции-сопрограмме, вызов функции-генератора не запускает её. Вместо этого создаётся объект-генератор:
"""
# get_random_number()
# <generator object get_random_number at 0x1048671c0>
"""
Вы можете перейти к следующему yield этапу генератора, используя встроенную функцию next(). 
Другими словами, генератор запускается, а затем останавливается. Например:
"""
generator = get_random_number()
next(generator)
# Hi
# 1
next(generator)
# Hello
# 7


# Задачи == Task
"""
Грубо говоря, задачи — это сопрограммы (а не функции сопрограмм), привязанные к циклу событий. 
Задача также хранит список функций обратного вызова, важность которых станет ясна, когда мы обсудим await. 

Рекомендуемый способ создания задач — через asyncio.create_task().

Создание задачи автоматически планирует ее выполнение 
(путем добавления обратного вызова для ее запуска в список дел цикла событий, то есть набор заданий).
Поскольку в каждом потоке только один цикл событий, asyncio он автоматически связывает задачу с циклом событий. 
Таким образом, нет необходимости указывать цикл событий.
"""
print("#1")
async def main():
    coroutine = loudmouth_penguin(magic_number=5)
    # This creates a Task object and schedules its execution via the event loop.
    task = asyncio.create_task(coroutine)

asyncio.run(main())
"""
Ранее мы вручную создали цикл событий и настроили его на бесконечное выполнение. 
На практике рекомендуется использовать (и это часто встречается) asyncio.run(), 
который управляет циклом событий и обеспечивает завершение предоставленной сопрограммы перед продолжением выполнения. 
Например, многие асинхронные программы используют такую  настройку:
"""
print("#2")
async def main():
    # Perform all sorts of wacky, wild asynchronous things...
    ...

if __name__ == "__main__":
    asyncio.run(main())
    # The program will not reach the following print statement until the
    # coroutine main() finishes.
    print("coroutine main() is done!")

"""
Важно понимать, что сама задача не добавляется в цикл обработки событий, 
добавляется только обратный вызов к ней. 
Это имеет значение, если созданный вами объект задачи удаляется сборщиком мусора до того, 
как он будет вызван циклом обработки событий. 
Например, рассмотрим следующую программу:
"""
print("#3")
async def hello():
    print("hello!")

async def main():
    asyncio.create_task(hello()) # line 5
    # Other asynchronous instructions which run for a while
    # and cede control to the event loop...
    ...

asyncio.run(main())
"""
Поскольку ссылки на объект задачи, созданный в строке 5, нет, 
он может быть собран мусором до того, как цикл событий его вызовет. 

Последующие инструкции в сопрограмме main() возвращают управление циклу событий, 
чтобы он мог вызвать другие задания. Когда цикл событий в конце концов попытается выполнить задачу, 
он может потерпеть неудачу и обнаружить, что объект задачи не существует! 
Это также может произойти, даже если сопрограмма сохраняет ссылку на задачу, 
но завершается до того, как эта задача завершится. 
При выходе из сопрограммы локальные переменные выходят из области видимости и могут быть подвергнуты сборке мусора. 
На практике asyncio сборщик мусора Python прилагает все усилия, 
чтобы предотвратить подобные ситуации. Но это не повод для безрассудства!
"""
# Ждать == Await
"""
await— ключевое слово Python, которое обычно используется в одном из двух способов:
"""
# await task
# await coroutine
"""
В решающей степени поведение await зависит от типа ожидаемого объекта.
Ожидание задачи передаёт управление от текущей задачи или сопрограммы циклу событий. 
В процессе передачи управления происходит несколько важных событий. 
Для иллюстрации воспользуемся следующим примером кода:
"""
async def dig_the_hole():
    print("hello!")

async def plant_a_tree():
    dig_the_hole_task = asyncio.create_task(dig_the_hole())
    await dig_the_hole_task

    # Other instructions associated with planting a tree.
    ...
"""
В этом примере представьте, что цикл обработки событий передал управление началу сопрограммы plant_a_tree(). 
Как видно выше, сопрограмма создаёт задачу и ожидает её выполнения. 
Инструкция await dig_the_hole_task добавляет обратный вызов (который возобновит выполнение plant_a_tree()) 
в список обратных вызовов объекта dig_the_hole_task. Затем инструкция передаёт управление циклу обработки событий. 
Некоторое время спустя цикл обработки событий передаст управление dig_the_hole_task, и задача завершит выполнение всех необходимых действий. 
После завершения задачи она добавит в цикл обработки событий различные обратные вызовы, 
в данном случае — вызов resume plant_a_tree().

В общем случае, когда ожидаемая задача завершается ( dig_the_hole_task), 
исходная задача или сопрограмма ( plant_a_tree()) добавляется обратно в список дел цикла событий для возобновления.
Это базовая, но надёжная ментальная модель. На практике передача управления немного сложнее, но ненамного. 
Во второй части мы рассмотрим детали, которые делают это возможным.
В отличие от задач, ожидание сопрограммы не возвращает управление циклу событий! 
Если сначала обернуть сопрограмму в задачу, а затем ожидать её, управление будет передано. 
Поведение сопрограммы фактически такое же, как и при вызове обычной синхронной функции Python. 
Рассмотрим следующую программу:
"""
# await coroutine

print("#4")

async def coro_a():
   print("I am coro_a(). Hi!")

async def coro_b():
   print("I am coro_b(). I sure hope no one hogs the event loop...")

async def main():
   task_b = asyncio.create_task(coro_b())
   num_repeats = 3
   for _ in range(num_repeats):
      await coro_a()
   await task_b

asyncio.run(main())
# I am coro_a(). Hi!
# I am coro_a(). Hi!
# I am coro_a(). Hi!
# I am coro_b(). I sure hope no one hogs the event loop...
"""
Первый оператор в сопрограмме main() создаёт task_b
её и планирует её выполнение через цикл событий. 
Затем coro_a() многократно выполняется ожидание. 
Управление никогда не передаётся циклу событий, поэтому мы видим вывод всех трёх coro_a() вызовов перед coro_b() выводом :

I am coro_a(). Hi!
I am coro_a(). Hi!
I am coro_a(). Hi!
I am coro_b(). I sure hope no one hogs the event loop...

Если заменить await coro_a() на await asyncio.create_task(coro_a()), поведение изменится. 
Этим оператором сопрограмма main() передаёт управление циклу событий. Затем цикл событий проходит весь накопленный объём работы, 
вызывая task_b, а затем задачу, которая оборачивает coro_a() перед возобновлением сопрограммы main().

I am coro_b(). I sure hope no one hogs the event loop...
I am coro_a(). Hi!
I am coro_a(). Hi!
I am coro_a(). Hi!

Такое поведение сопрограммы await может сбить с толку многих! 
Этот пример показывает, как использование только сопрограммы await может непреднамеренно перехватить управление у других задач 
и фактически остановить цикл событий. asyncio.run() 
может помочь обнаружить такие ситуации с помощью флага debug=True, 
который соответственно включает режим отладки. Помимо прочего, он будет регистрировать все сопрограммы, 
которые монополизируют выполнение в течение 100 мс или дольше.

В дизайне намеренно снижена концептуальная ясность использования await ради повышения производительности. 
Каждый раз, когда задача ожидает выполнения, управление необходимо передать по стеку вызовов циклу событий. 
Это может показаться мелочью, но в большой программе с большим количеством await 
и глубоким стеком вызовов такие накладные расходы могут существенно снизить производительность.
"""
