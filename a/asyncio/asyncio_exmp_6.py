import asyncio

# A conceptual overview part 2: the nuts and bolts
"""
управление циклу событий. Некоторое время спустя цикл событий передаст управление задаче , и задача завершит выполнение всех необходимых действий. После завершения задачи она добавит в цикл событий различные обратные вызовы, в данном случае вызов resume .await dig_the_hole_taskplant_a_tree()dig_the_hole_taskdig_the_hole_taskplant_a_tree()

В общем случае, когда ожидаемая задача завершается ( dig_the_hole_task), исходная задача или сопрограмма ( plant_a_tree()) добавляется обратно в список дел цикла событий для возобновления.

Это базовая, но надёжная ментальная модель. На практике передача управления немного сложнее, но ненамного. Во второй части мы рассмотрим детали, которые делают это возможным.

В отличие от задач, ожидание сопрограммы не возвращает управление циклу событий! Если сначала обернуть сопрограмму в задачу, а затем ожидать её, управление будет передано. Поведение сопрограммы фактически такое же, как и при вызове обычной синхронной функции Python. Рассмотрим следующую программу:await coroutine

import asyncio

async def coro_a():
   print("I am coro_a(). Hi!")

async def coro_b():
   print("I am coro_b(). I sure hope no one hogs the event loop...")

async def main():
   task_b = asyncio.create_task(coro_b())
   num_repeats = 3
   for _ in range(num_repeats):
      await coro_a()
   await task_b

asyncio.run(main())
Первый оператор в сопрограмме main()создаёт task_bеё и планирует её выполнение через цикл событий. Затем coro_a()многократно выполняется ожидание. Управление никогда не передаётся циклу событий, поэтому мы видим вывод всех трёх coro_a() вызовов перед coro_b()выводом :

I am coro_a(). Hi!
I am coro_a(). Hi!
I am coro_a(). Hi!
I am coro_b(). I sure hope no one hogs the event loop...
Если изменить на , поведение изменится. Этим оператором сопрограмма передаёт управление циклу событий. Затем цикл событий проходит весь накопленный объём работы, вызывая , а затем задачу, которая завершается перед возобновлением сопрограммы .await coro_a()await asyncio.create_task(coro_a())main()task_bcoro_a()main()

I am coro_b(). I sure hope no one hogs the event loop...
I am coro_a(). Hi!
I am coro_a(). Hi!
I am coro_a(). Hi!
Такое поведение может сбить с толку многих! Этот пример показывает, как использование only может непреднамеренно перехватить управление у других задач и фактически остановить цикл событий. Флаг, который соответственно включает режим отладки, поможет вам обнаружить такие ситуации . Помимо прочего, он будет регистрировать все сопрограммы, которые монополизируют выполнение в течение 100 мс или дольше.await coroutineawait coroutineasyncio.run()debug=True

В дизайне намеренно снижена концептуальная ясность использования awaitради повышения производительности. Каждый раз, когда ожидается выполнение задачи, управление необходимо передать по всему стеку вызовов, вплоть до цикла обработки событий. Это может показаться мелочью, но в большой программе с большим количеством await' и глубоким стеком вызовов такие накладные расходы могут существенно снизить производительность.

Концептуальный обзор, часть 2: гайки и болты 
Во второй части подробно рассматриваются механизмы asyncioуправления потоком управления. Именно здесь и происходит волшебство. Вы получите представление о том, что awaitпроисходит за кулисами, и о том, как создавать собственные асинхронные операторы.

Внутренняя работа сопрограмм 
asyncioиспользует четыре компонента для передачи управления.

coroutine.send(arg)— это метод, используемый для запуска или возобновления сопрограммы. Если сопрограмма была приостановлена ​​и теперь возобновляется, аргумент arg будет передан как возвращаемое значение оператора yield, который изначально её приостановил. Если сопрограмма используется впервые (а не возобновляется), argнеобходимо указать None.

class Rock:
    def __await__(self):
        value_sent_in = yield 7
        print(f"Rock.__await__ resuming with value: {value_sent_in}.")
        return value_sent_in

async def main():
    print("Beginning coroutine main().")
    rock = Rock()
    print("Awaiting rock...")
    value_from_rock = await rock
    print(f"Coroutine received value: {value_from_rock} from rock.")
    return 23

coroutine = main()
intermediate_result = coroutine.send(None)
print(f"Coroutine paused and returned intermediate value: {intermediate_result}.")

print(f"Resuming coroutine and sending in value: 42.")
try:
    coroutine.send(42)
except StopIteration as e:
    returned_value = e.value
print(f"Coroutine main() finished and provided value: {returned_value}.")
yield , как обычно, приостанавливает выполнение и возвращает управление вызывающему объекту. В приведенном выше примере метод yieldyieldв строке 3 вызывается методом в строке 11. В более широком смысле,он вызываетметод заданного объекта. Также выполняет ещё одну весьма специфичную функцию: распространяет (или «передаёт») любойполученный им объект s по цепочке вызовов. В данном случае это происходитв строке 16.... = await rockawait__await__()awaityield... = coroutine.send(None)

Выполнение сопрограммы возобновляется coroutine.send(42)вызовом в строке 21. Сопрограмма возобновляет выполнение с того места, где она yieldостановилась (или была приостановлена) в строке 3, и выполняет оставшиеся операторы в своём теле. После завершения сопрограммы возникает StopIterationисключение с возвращаемым значением, прикреплённым к valueатрибуту.

Этот фрагмент выводит следующий результат:

Beginning coroutine main().
Awaiting rock...
Coroutine paused and returned intermediate value: 7.
Resuming coroutine and sending in value: 42.
Rock.__await__ resuming with value: 42.
Coroutine received value: 42 from rock.
Coroutine main() finished and provided value: 23.
Здесь стоит на мгновение остановиться и убедиться, что вы проследили все способы передачи управляющего потока и значений. Было рассмотрено много важных идей, и стоит убедиться, что вы всё хорошо поняли.

Единственный способ передать управление (или фактически передать управление) сопрограмме — это awaitобъекту, yieldнаходящемуся в её __await__методе. Это может показаться вам странным. Вы можете подумать:

1. А как насчёт yieldфункции непосредственно внутри сопрограммы? Функция сопрограммы становится функцией асинхронного генератора , что совершенно не похоже на оригинал.

2. Что насчёт передачи управления из функции сопрограммы (обычному) генератору? Это приводит к ошибке: это было намеренно разработано для простоты — предписывая только один способ использования сопрограмм. Изначально это также было запрещено, но затем снова принято, чтобы разрешить использование асинхронных генераторов. Несмотря на это, фактически это то же самое.SyntaxError: yield from not allowed in a coroutine.yieldyield fromawait

Фьючерсы 
Future — это объект, предназначенный для представления состояния и результата вычисления. Этот термин отсылает к идее чего-то , что ещё должно произойти или ещё не произошло, и объект — это способ следить за этим.

У будущего есть несколько важных атрибутов. Один из них — его состояние, которое может быть «ожидание», «отменено» или «выполнено». Другой — его результат, который устанавливается при переходе состояния в «выполнено». В отличие от сопрограммы, будущее не представляет фактическое вычисление, которое должно быть выполнено; вместо этого оно отображает статус и результат этого вычисления, своего рода индикатор состояния (красный, жёлтый или зелёный).

asyncio.TaskПодклассы asyncio.Futureдля получения этих разнообразных возможностей. В предыдущем разделе говорилось, что задачи хранят список обратных вызовов, что было не совсем верно. На самом деле Futureэту логику реализует класс, который Task наследует.

Фьючерсы также можно использовать напрямую (не через задачи). Задачи отмечают себя как выполненные после завершения своей сопрограммы. Фьючерсы гораздо более универсальны и будут отмечены как выполненные, когда вы этого захотите. Таким образом, они представляют собой гибкий интерфейс для создания собственных условий ожидания и возобновления.

Самодельный asyncio.sleep 
Мы рассмотрим пример того, как вы можете использовать будущее для создания собственного варианта асинхронного сна ( async_sleep), который имитирует asyncio.sleep().

Этот фрагмент регистрирует несколько задач в цикле событий, а затем ожидает сопрограмму, обёрнутую в задачу: async_sleep(3). Мы хотим, чтобы эта задача завершилась только по истечении трёх секунд, но без остановки выполнения других задач.

async def other_work():
    print("I like work. Work work.")

async def main():
    # Add a few other tasks to the event loop, so there's something
    # to do while asynchronously sleeping.
    work_tasks = [
        asyncio.create_task(other_work()),
        asyncio.create_task(other_work()),
        asyncio.create_task(other_work())
    ]
    print(
        "Beginning asynchronous sleep at time: "
        f"{datetime.datetime.now().strftime("%H:%M:%S")}."
    )
    await asyncio.create_task(async_sleep(3))
    print(
        "Done asynchronous sleep at time: "
        f"{datetime.datetime.now().strftime("%H:%M:%S")}."
    )
    # asyncio.gather effectively awaits each task in the collection.
    await asyncio.gather(*work_tasks)
Ниже мы используем будущий объект, чтобы настроить управление моментом, когда задача будет отмечена как выполненная. Если future.set_result()метод, отвечающий за отметку будущего объекта как выполненного, никогда не будет вызван, то эта задача никогда не завершится. Мы также заручились помощью другой задачи, которую мы увидим чуть позже, которая будет отслеживать прошедшее время и, соответственно, вызывать future.set_result().

async def async_sleep(seconds: float):
    future = asyncio.Future()
    time_to_wake = time.time() + seconds
    # Add the watcher-task to the event loop.
    watcher_task = asyncio.create_task(_sleep_watcher(future, time_to_wake))
    # Block until the future is marked as done.
    await future
Ниже мы используем довольно простой объект , YieldToEventLoop()чтобы yield передать __await__управление циклу событий. По сути, это то же самое, что вызвать asyncio.sleep(0), но такой подход обеспечивает большую ясность, не говоря уже о том, что это несколько нечестно asyncio.sleepпри демонстрации реализации!

Как обычно, цикл событий циклически проходит через свои задачи, передавая им управление и получая его обратно, когда они приостанавливаются или завершаются. watcher_task, который запускает сопрограмму _sleep_watcher(...), будет вызываться один раз за полный цикл цикла событий. При каждом возобновлении он будет проверять время, и если прошло недостаточно времени, то он снова приостановится и передаст управление обратно циклу событий. В конце концов, когда пройдет достаточно времени, _sleep_watcher(...)будущая задача будет отмечена как выполненная, а затем сама завершится, вырвавшись из бесконечного whileцикла. Учитывая, что эта вспомогательная задача вызывается только один раз за цикл цикла событий, вы будете правы, заметив, что этот асинхронный сон будет спать не менее трех секунд, а не ровно три. Обратите внимание, что это также верно для asyncio.sleep.

class YieldToEventLoop:
    def __await__(self):
        yield

async def _sleep_watcher(future, time_to_wake):
    while True:
        if time.time() >= time_to_wake:
            # This marks the future as done.
            future.set_result(None)
            break
        else:
            await YieldToEventLoop()
Вот полный вывод программы:

$ python custom-async-sleep.py
Beginning asynchronous sleep at time: 14:52:22.
I like work. Work work.
I like work. Work work.
I like work. Work work.
Done asynchronous sleep at time: 14:52:25.
Вам может показаться, что эта реализация асинхронного сна излишне запутана. И, по сути, так оно и есть. Целью этого примера было продемонстрировать универсальность фьючерсов на простом примере, который можно было бы использовать для более сложных задач. Для справки, вы можете реализовать это без фьючерсов, например, так:

async def simpler_async_sleep(seconds):
    time_to_wake = time.time() + seconds
    while True:
        if time.time() >= time_to_wake:
            return
        else:
            await YieldToEventLoop()
Но на этом всё. Надеюсь, вы готовы более уверенно погрузиться в асинхронное программирование или изучить более сложные темы в .rest of the documentation
"""